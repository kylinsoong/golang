package as3perf

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"os"
	"reflect"
	"strings"
	"time"

	log "github.com/kylinsoong/as3-benchmark/pkg/vlogger"
)

var (
	httpClient *http.Client
	globalMap  = make(map[string]bool)
)

var baseAS3Config = `{
	"$schema": "https://raw.githubusercontent.com/F5Networks/f5-appsvcs-extension/master/schema/%s/as3-schema-%s.json",
	"class": "AS3",
	"declaration": {
	  "class": "ADC",
	  "schemaVersion": "%s",
	  "id": "urn:uuid:85626792-9ee7-46bb-8fc8-4ba708cfdc1d",
	  "label": "CIS Declaration",
	  "remark": "Auto-generated by CIS",
	  "controls": {
              "class": "Controls",
              "userAgent": "CIS Configured AS3"
	  }
	}
}     
`

type (
	as3Template        string
	as3Declaration     string
	as3ADC             as3JSONWithArbKeys
	as3Control         as3JSONWithArbKeys
	as3Tenant          as3JSONWithArbKeys
	as3Application     as3JSONWithArbKeys
	as3JSONWithArbKeys map[string]interface{}

	poolName   string
	appName    string
	tenantName string
	tenant     map[appName][]poolName
	as3Object  map[tenantName]tenant
)

type config struct {
	data      string
	as3APIURL string
}

type AS3Config struct {
	resourceConfig        as3ADC
	configmaps            []*AS3ConfigMap
	overrideConfigmapData string
	tenantMap             map[string]interface{}
	unifiedDeclaration    as3Declaration
}

type AS3ConfigMap struct {
	Name      string   // AS3 specific ConfigMap name
	Namespace string   // AS3 specific ConfigMap namespace
	config    as3ADC   // if AS3 Name is present, populate this with AS3 template data.
	endPoints []Member // Endpoints of all the pools in the configmap
	Validated bool     // Json Schema validated ok
}

type Member struct {
	Address string `json:"address"`
	Port    int32  `json:"port"`
	SvcPort int32  `json:"svcPort"`
	Session string `json:"session,omitempty"`
}

func generateIP() string {
	ip := fmt.Sprintf("10.244.%d.%d", rand.Intn(256), rand.Intn(255))
	if globalMap[ip] {
		return generateIP()
	} else {
		globalMap[ip] = true
		return ip
	}
}

func createHTTPClient() *http.Client {
	rootCAs, _ := x509.SystemCertPool()
	certs := []byte("")
	if ok := rootCAs.AppendCertsFromPEM(certs); !ok {

	}

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
			RootCAs:            rootCAs,
		},
	}

	timeoutLarge := 60 * time.Second
	httpClient = &http.Client{
		Transport: tr,
		Timeout:   timeoutLarge,
	}
	return httpClient
}

func httpReq(request *http.Request) (*http.Response, map[string]interface{}) {
	httpResp, err := httpClient.Do(request)
	if err != nil {
		fmt.Printf("[AS3] REST call error: %v ", err)
		os.Exit(1)
	}

	defer httpResp.Body.Close()

	body, err := ioutil.ReadAll(httpResp.Body)
	if err != nil {
		fmt.Printf("[AS3] REST call response error: %v ", err)
		os.Exit(1)
	}
	var response map[string]interface{}
	err = json.Unmarshal(body, &response)
	if err != nil {
		fmt.Printf("[AS3] Response body unmarshal failed: %v\n", err)
		os.Exit(1)
	}
	return httpResp, response
}

func getEmptyAs3Declaration(partition string) as3Declaration {

	var as3Config map[string]interface{}
	baseAS3ConfigEmpty := fmt.Sprintf(baseAS3Config, "3.36.1", "3.36.1-1", "3.36.0")
	_ = json.Unmarshal([]byte(baseAS3ConfigEmpty), &as3Config)
	decl := as3Config["declaration"].(map[string]interface{})

	controlObj := make(as3Control)
	controlObj["class"] = "Controls"
	controlObj["userAgent"] = "CIS/v K8S/v 1.23.10"
	decl["controls"] = controlObj

	decl[partition] = map[string]string{"class": "Tenant"}
	data, _ := json.Marshal(as3Config)
	emptyAS3Declaration := as3Declaration(data)
	return emptyAS3Declaration
}

func getAS3APIURL(host string, tenants []string) string {
	apiURL := fmt.Sprintf("https://%s/mgmt/shared/appsvcs/declare/%s", host, strings.Join(tenants, ","))
	return apiURL
}

func GetAppEndpoints() []Member {

	var members []Member

	member1 := Member{
		Address: generateIP(),
		Port:    8080,
		SvcPort: 80,
	}
	member2 := Member{
		Address: generateIP(),
		Port:    8080,
		SvcPort: 80,
	}

	member3 := Member{
		Address: generateIP(),
		Port:    8080,
		SvcPort: 80,
	}

	member4 := Member{
		Address: generateIP(),
		Port:    8080,
		SvcPort: 80,
	}

	member5 := Member{
		Address: generateIP(),
		Port:    8080,
		SvcPort: 80,
	}

	members = append(members, member1)
	members = append(members, member2)
	members = append(members, member3)
	members = append(members, member4)
	members = append(members, member5)

	return members
}

func assertToBe(kind string, obj interface{}) bool {
	if obj == nil {
		return false
	}
	return (reflect.TypeOf(obj).Kind().String() == kind)
}

func getClass(obj interface{}) string {
	cfg, ok := obj.(map[string]interface{})
	if !ok {
		// If not a json object it doesn't have class attribute
		return ""
	}
	cl, ok := cfg["class"]
	if !ok {
		fmt.Println("No class attribute found")
		return ""
	}
	return cl.(string)
}

func getAS3ObjectFromTemplate(template as3Template) (as3Object, bool) {

	var tmpl map[string]interface{}
	err := json.Unmarshal([]byte(template), &tmpl)
	if err != nil {
		fmt.Errorf("[AS3] JSON unmarshal failed: %v  %v", err, template)
		return nil, false
	}

	as3 := make(as3Object)
	dclr := tmpl["declaration"]
	if dclr == nil || !assertToBe("map", dclr) {
		fmt.Println("[AS3] No ADC class declaration found or with wrong content.")
		return nil, false
	}

	for tn, t := range dclr.(map[string]interface{}) {
		if !assertToBe("map", t) {
			continue
		}
		tnt := t.(map[string]interface{})
		if tnt["class"] != "Tenant" {
			continue
		}
		as3[tenantName(tn)] = make(tenant, 0)
		for an, a := range t.(map[string]interface{}) {
			if !assertToBe("map", a) {
				continue
			}
			as3[tenantName(tn)][appName(an)] = []poolName{}
			for pn, v := range a.(map[string]interface{}) {
				if !assertToBe("map", v) {
					continue
				}
				if cl := getClass(v); cl != "Pool" {
					continue
				}
				mems := (v.(map[string]interface{}))["members"]
				if mems == nil {
					continue
				}
				if !assertToBe("slice", mems) || len(mems.([]interface{})) == 0 {
					continue
				}
				if !assertToBe("map", (mems.([]interface{}))[0]) {
					continue
				}
				mem0 := (mems.([]interface{}))[0].(map[string]interface{})
				srvAddrs := mem0["serverAddresses"]
				if srvAddrs == nil || len(srvAddrs.([]interface{})) != 0 {
					continue
				}
				as3[tenantName(tn)][appName(an)] = append(
					as3[tenantName(tn)][appName(an)],
					poolName(pn),
				)
			}
			if len(as3[tenantName(tn)][appName(an)]) == 0 {
				fmt.Printf("[AS3] No pools declared for application: %s, tenant: %s\n", an, tn)
			}
		}
	}
	if len(as3) == 0 {
		fmt.Println("[AS3] No tenants declared in AS3 template")
		return as3, false
	}
	return as3, true
}

func readFileFromCurrentDir(filePath string) (string, error) {

	// Read the entire file contents into a string
	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		return "", err
	}

	// Convert the byte slice to a string
	fileContentString := string(content)

	return fileContentString, nil
}

func processCfgMap(name string) (map[string]interface{}, []Member) {

	data, err := readFileFromCurrentDir(name)
	if err != nil {
		log.Errorf("Error: %v", err)
		return nil, nil
	}
	as3Tmpl := as3Template(data)
	obj, ok := getAS3ObjectFromTemplate(as3Tmpl)
	if !ok {
		fmt.Println("[AS3][Configmap] Error processing AS3 template")
		fmt.Printf("[AS3]Error in processing the ConfigMap: %v/%v", "f5-hub-1", "cm-cistest")
		return nil, nil
	}

	if _, ok := obj[tenantName("k8s")]; ok {
		fmt.Printf("[AS3] Error in processing the ConfigMap: %v/%v", "f5-hub-1", "cm-cistest")
		fmt.Printf("[AS3] CIS managed partition <%s> should not be used in ConfigMaps as a Tenant", "k8s")
		return nil, nil
	}

	var tmp interface{}

	err = json.Unmarshal([]byte(as3Tmpl), &tmp)
	if nil != err {
		return nil, nil
	}

	templateJSON := tmp.(map[string]interface{})
	dec := (templateJSON["declaration"]).(map[string]interface{})
	tenantMap := make(map[string]interface{})
	var members []Member

	for tnt, apps := range obj {
		tenantObj := dec[string(tnt)].(map[string]interface{})
		tenantObj["defaultRouteDomain"] = 0
		for app, pools := range apps {
			appObj := tenantObj[string(app)].(map[string]interface{})
			for _, pn := range pools {
				poolObj := appObj[string(pn)].(map[string]interface{})
				eps := GetAppEndpoints()
				if len(eps) == 0 {
					continue
				}
				poolMem := (((poolObj["members"]).([]interface{}))[0]).(map[string]interface{})
				var ips []string
				var port int32
				for _, v := range eps {
					if int(v.SvcPort) == int(poolMem["servicePort"].(float64)) {
						ips = append(ips, v.Address)
						members = append(members, v)
						port = v.Port
					}
				}
				if port == 0 {
					ipMap := make(map[string]bool)
					members = append(members, eps...)
					for _, v := range eps {
						if _, ok := ipMap[v.Address]; !ok {
							ipMap[v.Address] = true
							ips = append(ips, v.Address)
						}
					}
					port = eps[0].Port
				}
				poolMem["serverAddresses"] = ips
				poolMem["servicePort"] = port
			}
		}
		tenantMap[string(tnt)] = tenantObj
	}
	return tenantMap, members
}

func exreact_tenant_names(name string) []string {
	tenantMap, _ := processCfgMap(name)
	partitions := make([]string, 0, len(tenantMap))
	for partition := range tenantMap {
		partitions = append(partitions, partition)
	}
	return partitions
}

func execute_http_post(cfg config, username string, password string) {

	httpReqBody := bytes.NewBuffer([]byte(cfg.data))

	req, err := http.NewRequest("POST", cfg.as3APIURL, httpReqBody)
	if err != nil {
		log.Errorf("[AS3] Creating new HTTP request error: %v ", err)
	}
	log.Infof("[AS3] posting request to %s", cfg.as3APIURL)

	req.SetBasicAuth(username, password)
	httpClient = createHTTPClient()
	httpResp, responseMap := httpReq(req)
	log.Debugf("httpResp: %v, response: %v", httpResp, responseMap)

	results := (responseMap["results"]).([]interface{})
	for _, value := range results {
		v := value.(map[string]interface{})
		log.Infof("[AS3] Response from BIG-IP: code: %v, tenant: %v, message: %v, runTime: %v", v["code"], v["tenant"], v["message"], v["runTime"])
	}
}

func process_deletion(partition, host, username, password string) {
	emptyAS3Declaration := getEmptyAs3Declaration(partition)
	data := string(emptyAS3Declaration)
	url := getAS3APIURL(host, []string{partition})
	log.Debugf("declaration: %s, url: %s", data, url)
	cfg := config{
		data:      data,
		as3APIURL: url,
	}
	execute_http_post(cfg, username, password)
}

func generateAS3ResourceDeclaration() as3ADC {

	app := as3Application{}
	app["class"] = "Application"
	app["template"] = "shared"

	tnt := as3Tenant{}
	tnt["class"] = "Tenant"
	tnt["Shared"] = app
	tnt["defaultRouteDomain"] = 0

	adc := as3ADC{}
	adc["k8s"] = tnt

	return adc
}

func prepareAS3ResourceConfig() as3ADC {

	adc := generateAS3ResourceDeclaration()
	controlObj := make(as3Control)
	controlObj["class"] = "Controls"
	controlObj["userAgent"] = "CIS/v K8S/v 1.23.10"
	adc["controls"] = controlObj

	return adc
}

func prepareResourceAS3ConfigMaps(name string) ([]*AS3ConfigMap, string) {

	var as3Cfgmaps []*AS3ConfigMap
	var overriderAS3CfgmapData string

	cfgmap := &AS3ConfigMap{
		Name:      "cm-cistest",
		Namespace: "f5-hub-1",
		Validated: true,
	}

	tenantMap, endPoints := processCfgMap(name)
	cfgmap.config = tenantMap
	cfgmap.endPoints = endPoints
	as3Cfgmaps = append(as3Cfgmaps, cfgmap)

	return as3Cfgmaps, overriderAS3CfgmapData
}

func updateTenantMap(tempAS3Config AS3Config) AS3Config {
	// Parse as3Config.configmaps , extract all tenants and store in tenantMap.
	for _, cm := range tempAS3Config.configmaps {
		for tenantName, tenant := range cm.config {
			tempAS3Config.tenantMap[tenantName] = tenant
		}
	}
	return tempAS3Config
}

func getADC() map[string]interface{} {
	var as3Obj map[string]interface{}
	baseAS3ConfigTemplate := fmt.Sprintf(baseAS3Config, "3.36.1", "3.36.1-1", "3.36.0")
	_ = json.Unmarshal([]byte(baseAS3ConfigTemplate), &as3Obj)
	return as3Obj
}

func prepareTenantDeclaration(cfg *AS3Config, tenantName string) as3Declaration {

	as3Obj := getADC()
	adc, _ := as3Obj["declaration"].(map[string]interface{})

	adc[tenantName] = cfg.tenantMap[tenantName]

	unifiedDecl, err := json.Marshal(as3Obj)
	if err != nil {
		log.Errorf("[AS3] Unified declaration: %v", err)
	}

	return as3Declaration(unifiedDecl)
}

func Deletion(declaration, host, username, password string) {
	partitions := exreact_tenant_names(declaration)
	for _, partition := range partitions {
		process_deletion(partition, host, username, password)
	}
}

func Addition(declaration, host, username, password string) {
	as3Config := &AS3Config{
		tenantMap: make(map[string]interface{}),
	}

	as3Config.resourceConfig = prepareAS3ResourceConfig()
	as3Config.configmaps, as3Config.overrideConfigmapData = prepareResourceAS3ConfigMaps(declaration)
	updateTenantMap(*as3Config)
	for partition, tenant := range as3Config.tenantMap {
		log.Debugf("%s, %v", partition, tenant)
		tenantDecl := prepareTenantDeclaration(as3Config, partition)
		data := string(tenantDecl)
		url := getAS3APIURL(host, []string{partition})
		//t.Logf("data: %s", data)
		//t.Logf("url: %s", url)
		cfg := config{
			data:      data,
			as3APIURL: url,
		}
		execute_http_post(cfg, username, password)
	}

}
