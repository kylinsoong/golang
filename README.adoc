= Golang Boot Camp
:toc: manual

== Getting started

* https://golang.org/doc/

=== Check go version

[source, go]
----
# go version
go version go1.21.5 linux/arm64
----

=== package, import, main

[source, go]
----
package main
  
import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
----

=== Run main methods

[source, go]
----
$ go run hello.go 
Hello, World!
----

=== Call External Methods

[source, go]
----
package main
  
import "fmt"

import "rsc.io/quote"

func main() {
    fmt.Println("Hello, World!")
    fmt.Println(quote.Glass())
    fmt.Println(quote.Go())
    fmt.Println(quote.Hello())
    fmt.Println(quote.Opt())
}
----

== Work with Go standard project

=== Project Structure

[source, go]
----
# tree greetings/
greetings/
├── cmd
│   └── greetings
│       └── main.go
└── pkg
    └── greetings
        ├── greetings.go
        └── greetings_test.go
----

A standard Go project structure can vary depending on the size and nature of the project, but there are some common conventions that many Go developers follow:

* *cmd*: The `cmd` directory is for the main applications of your project. Each application can have its own subdirectory. For example, myapp could be the main entry point for your application
* *internal*: The `internal` directory is for packages that are only used within your project, not meant for external use.
* *pkg*: The pkg directory contains libraries and packages that are meant to be used by other projects. Each package within pkg can have its own subdirectory.

=== Init and Setup Dependencies

[source, go]
----
go mod init github.com/kylinsoong/golang/greetings
go mod tidy
----

=== Run

[source, go]
----
go run cmd/greetings/main.go
----

=== How main module call pkg module

[source, go]
----
package main

import (
    "github.com/kylinsoong/golang/greetings/pkg/greetings"
)

func main() {
    names := []string{"Gladys", "Samantha", "Darrin", "Kylin"}
    messages, err := greetings.Hellos(names)
}
----

=== Run Unit Test

[source, go]
----
go test ./pkg/greetings/ 
----

=== Build

[source, go]
----
go build -o a.out cmd/greetings/*.go
----

=== Run Binary File

[source, go]
----
# ./a.out
----

== Data Struct

=== simple map

[source, go]
----
    processedResources := make(map[string]bool)

    processedResources["foo.yaml"] = true
    processedResources["bar.yaml"] = false
    processedResources["zoo.yaml"] = false

    for key, value := range processedResources {
        fmt.Printf("%s: %v\n", key, value)
    }

    fmt.Println(processedResources["zoo.yaml"])

    value, exists := processedResources["coo.yaml"]
    if exists {
        fmt.Printf("coo.yaml: %v\n", value)
    } else {
        fmt.Println("coo.yaml not exist")
    }
----

=== simple struct

[source, go]
----
type WatchedNamespaces struct {
    Namespaces     []string
    NamespaceLabel string
}

func main() {
    watchedNamespaces := WatchedNamespaces{
        Namespaces:     []string{"namespace1", "namespace2"},
        NamespaceLabel: "watched",
    }

    fmt.Println(watchedNamespaces.Namespaces)
    fmt.Println(watchedNamespaces.NamespaceLabel)
}
----

=== struct with func field

Using a Go struct with a function field offers flexibility and allows you to encapsulate behavior within the struct while enabling dynamic customization.

[source, go]
.*Example*
----
type Manager struct {
    queueLen            int
    processAgentLabels  func(map[string]string, string, string) bool
}

func customProcessAgentLabels(labels map[string]string, namespace string, name string) bool {
    fmt.Printf("Custom Processing Agent Labels: %v, Namespace: %s, Name: %s\n", labels, namespace, name)
    return true
}

func main() {
    appMgr := Manager{
        queueLen:           10,
        processAgentLabels: customProcessAgentLabels,
    }
    appMgr.processAgentLabels(map[string]string{"key": "value"}, "exampleNamespace", "exampleName")
}
----

== Multi-threads

=== goroutine

The goroutine is a lightweight thread of execution managed by the Go runtime. Goroutines enable concurrent programming in a way that is more efficient and scalable compared to traditional threads.

[source, go]
.*Example*
----
package main

import (
	"fmt"
	"time"
)

func printNumbers() {
    for i := 1; i <= 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Printf("%d \n", i)
    }
}

func main() {
    go printNumbers()

    for i := 1; i <= 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Printf("A%d \n", i)
    }
}
----
